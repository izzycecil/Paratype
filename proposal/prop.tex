% THIS IS SIGPROC-SP.TEX - VERSION 3.1
% WORKS WITH V3.2SP OF ACM_PROC_ARTICLE-SP.CLS
% APRIL 2009
%
% It is an example file showing how to use the 'acm_proc_article-sp.cls' V3.2SP
% LaTeX2e document class file for Conference Proceedings submissions.
% ----------------------------------------------------------------------------------------------------------------
% This .tex file (and associated .cls V3.2SP) *DOES NOT* produce:
%       1) The Permission Statement
%       2) The Conference (location) Info information
%       3) The Copyright Line with ACM data
%       4) Page numbering
% ---------------------------------------------------------------------------------------------------------------

\documentclass{acm_proc_article-sp}
\usepackage{listings,color,xcolor}
\usepackage{pgf,tikz,pgfgantt}
\usepackage{lmodern} % font problem fix

\usepackage{subcaption}
\usepackage{graphicx}
\usepackage{float,dblfloatfix,fixltx2e}
\usepackage[format=plain,font=small,labelfont=bf]{caption}
\usepackage[utf8]{inputenc}
\usepackage{syntax, etoolbox}
\usepackage{lstlang0}

\definecolor{dkgreen}{rgb}{0,0.6,0}
\AtBeginEnvironment{grammar}{\small}

\usepackage{MnSymbol}
\lstset{
	prebreak=\raisebox{0ex}[0ex][0ex]{\ensuremath{\rhookswarrow}},
	postbreak=\raisebox{0ex}[0ex][0ex]{\ensuremath{\rcurvearrowse\space}},
	breaklines=true,
	numbers=left,
	numberstyle=\scriptsize,
	breakatwhitespace=true,
	frame=single,
	frameround=tttt,
	tabsize=4,
	showstringspaces=false,
	aboveskip=1.8em,
	belowskip=0em,
	captionpos=b,
	xleftmargin=0.4em,
	xrightmargin=0em,
	keywordstyle=\bfseries\color{dkgreen},
	commentstyle=\itshape\color{purple},
	identifierstyle=\color{black},
	stringstyle=\color{blue},
	basicstyle=\small\ttfamily
}

\lstdefinelanguage{Paratype}{
	morekeywords={func,inherits,implements,throws,type,typeclass,contrain,to},
}

\newganttchartelement{chris}{
	chris/.style={
		color=black,
		fill=red,
		shape=ganttbar,
		inner sep=0pt,
		draw
	},
	chris height=0.5
}
\newganttchartelement{tyler}{
	tyler/.style={
		color=black,
		fill=green,
		shape=ganttbar,
		inner sep=0pt,
		draw
	},
	tyler height=.5
}
\newganttchartelement{ben}{
	ben/.style={
		color=black,
		fill=blue,
		shape=ganttbar,
		inner sep=0pt,
		draw
	},
	ben height=.5
}

\setlength{\grammarparsep}{8pt plus 1pt minus 1pt}
\setlength{\grammarindent}{12em}

\begin{document}

\title{Paratype --- A Parallel Type Completion System}


% You need the command \numberofauthors to handle the 'placement
% and alignment' of the authors beneath the title.
\numberofauthors{3}
\author{
\alignauthor
Tyler Cecil\\
       \affaddr{New Mexico Tech}\\
       \affaddr{801 Leroy Place}\\
       \affaddr{Socorro, NM 87801 USA}\\
       \email{tcecil@nmt.edu}
\alignauthor
Ben Turrubiates\\
       \affaddr{New Mexico Tech}\\
       \affaddr{801 Leroy Place}\\
       \affaddr{Socorro, NM 87801 USA}\\
       \email{bturrubi@nmt.edu}
\alignauthor
Christopher Koch\\
       \affaddr{New Mexico Tech}\\
       \affaddr{801 Leroy Place}\\
       \affaddr{Socorro, NM 87801 USA}\\
       \email{ckoch@cs.nmt.edu}
}
\date{\today}

\maketitle
\begin{abstract}
\end{abstract}

\category{F.3.3}{Studies of Program Constructs}{Type structure}
\category{D.3.3}{Programming Languages}{Language Constructs and Features}
\category{D.3.4}{Programming Languages}{Processors}

% some out of 16 general terms!
\terms{Design, Languages, Performance}

\keywords{type theory, language theory, type completion, type checking, type
inference, code analysis, parallel}

\section{Introduction}

% problem and why important
% compilers: e.g. just-in-time comp

\section{Problem Definition}
\label{sec:problem}
% grammar, input/output, type completion, lambda calculus (System F)

Formally, our problem will be to take an input file of a specified grammar and
generate an output of either failure due to undecidability or the same file
with explicit types instead of type variables. In the process of doing this, we
will also be performing type checking. The goal is to find an explicit type for
each function call without type conflicts. Please see Appendix~\ref{app:Grammar}
for our EBNF grammar.

We define a few terms to use throughout the proposal:
\begin{description}
	\item[Type] A set of values. Types may implement type classes.
	\item[Type class] A set of types. Type classes may inherit other type classes.
	\item[Context] The set of explicit types and metainformation associated
		with a function call: caller, parameter types, return type,
		and a list of functions who care about the context.
	\item[Partial context] A context where not all types are known explicitly.
	\item[Resolution] Resolving a context means giving it explicit types.
	\item[Parent (function)] Caller of a function.
	\item[Child (function)] A function that is called by its parent function.
    \item[Parametric Polymorphism] A way to allow a language to express the handling of functions and types homogeneously independent of their type through the use of generic functions. Also known as generic programming.
    \item[Bounded Parametric Polymorphism] A method of providing extra information about a generic data type. In Haskell this is achieved by creating a type class which types implement.
\end{description}

\begin{lstlisting}[caption=Grammar displayed informally,language=Paratype]
typeclass num inherits tc1, tc2, ...

type int implements num
    = othertype | (otype, otype, ...)

func foo(otype var, Typevar var2, ...)
    otype throws error1, error2, error3
    = bar(baz(var), var2) | otype
\end{lstlisting}

\begin{lstlisting}[caption=Explicit context provided by parents,language=Paratype]
func foo(int x, int y) int
    = bar(y)

func bar(T d) T
    = T
\end{lstlisting}

\begin{lstlisting}[caption=Explicit context provided by child,language=Paratype]
func foo(T a, S b) R
    = bar(a, b)

func bar(float a, float b) int
    = int
\end{lstlisting}

\begin{lstlisting}[caption=Explicit context provided by child and parent,language=Paratype]
func foo(T a, int b) int
    = barbar(a, b)

func barbar(int a, T b) R
    = R
\end{lstlisting}

\begin{lstlisting}[caption=Need to maintain partial contexts,language=Paratype]
func foo(int x) T
    = bar(x)

func bar(T b) char
    = char

func baz(float b) T
    = bar(b)
\end{lstlisting}

\begin{lstlisting}[caption=Unhalting context resolution,language=Paratype]
func foo(T b) int
    = bar(b)

func bar(T a) int
    = int
\end{lstlisting}

\begin{lstlisting}[caption=Errors,language=Paratype]
func foobar(T b) T
    = foo(b)

func foo(int b) int
    = bar(b)

func bar(T a) T throws weirdError
    = T
\end{lstlisting}

% ADD EXAMPLE OF NESTED FUNCTIONS

\section{Parallelization}

Paratype will act as an \emph{actor model} of computation for our type
system: \emph{every function will be an actor}. We feel that not only will
such a model be efficient for type resolution, but it also acts as a
natural solution to the problem. The type resolution process is
essentially a conversation between functions: a function asks others for
information about their type in order to resolve its own type. We take
advantage of this natural communication and process the problem in
parallel.

Unfortunately, the communication is not linear as shown by our
previous examples. This makes our task quite a bit more challenging;
especially if we want to keep communication overhead low! Each node
needs to communicate to its parents and children, send partial
contexts, and update error types. Actors also need to know when their
process should finish, compile, or error out. This complexity,
however, is not all for not.

\subsection{Expected Speedup}

Where does speedup come from, other than the parallel computation of
contexts? Consider a chain of function calls in which the last
function in the chain has a type constraint. In the serial case, types
would need to propagate all the way down to check for a type error. In
the parallel case, however, contexts move both up and down
concurrently. Meeting halfway, we can check for type errors. This
is only one factor and it only matters in invalid code. However, the
chains themselves can now be evaluated in parallel. If we are even
more clever, we can use shared memory for our contexts and thus allow
changes that occur at one end of a call graph to instantly propagate
to all other nodes without unnecessary message overhead. When
considering the factors that provide speedup for our application, it
becomes apparent that our speedup is a function of many attributes:
graph width, number of functions, invalid versus valid code, etc.
These need to be considered when building our model.

In some ways, speedup will be hard to measure: we do not have a serial
implementation for our toy language. Due to time constraints, we
have omitted implicit typing from our grammar (not that our system
could not handle it), which prevents us from simply resolving Haskell
types and comparing our results to \texttt{ghc} and
\texttt{hugs}. This is a future goal for us. At present, however,
we will be able to vary the number of processing nodes being
utilized via \texttt{GOMAXPROCS}.

\subsection{Expected Problems}

Moving contexts around is no trivial task. A huge amount of
bookkeeping will be required to prevent deadlock, hanging, unnecessary
contexts, and a host of other possible problems. Marking down where a
context came from is not even trivial: through composition of
function calls, an inner function of that composition may receive
contexts through wrapping functions of that composition. While none of
these problems are insurmountable, they require our code to be
constructed carefully.

%TODO: USE AN ACTUALL LABEL
Our examples in Section~\ref{sec:problem} show a number of problems that must be
resolved in our method. Perhaps the most daunting is knowing when
execution should complete. More subtle, however, are problems that
come from having no ``main'' function. In a traditional compiler
setting, we have a function to begin propagation from. We, however,
evaluate all contexts in parallel. With this lack of a starting point,
some communications become ambiguous: do we communicate down or up
the call tree? Do we wait to be signaled? There are many more questions. These
are all problems that will need to be resolved by Paratype.

\section{Methods}

% Google Go and why

Due to the actor model, the problem lends itself nicely to a distributed memory
approach; however, it is usually commodity hardware that is used for
compilation. Therefore, we propose to use Google Go due to its concept of
\texttt{goroutines}. A \texttt{goroutine} is a lightweight thread that is
managed by Go during runtime.

\begin{lstlisting}[caption=Small \texttt{goroutine} example with
\texttt{channels},language=Go,label=lst:goroutine]
func node(name string, c chan string) {
	fmt.Println("I'm node ", name)
	/* send message to c 
	 * (blocks until receiver is ready)
	 */
	c <- strings.Join(name, " has a message for you.")
}

func main() {
	// unbuffered channel
	c := make(chan string)
	go node("abc", c)
	// receive message from c (blocks)
	a := <-c
	fmt.Println(a)
}
\end{lstlisting}

It is possible to pass references through shared memory, called
\texttt{channels}, with \texttt{goroutines}: like message passing in shared
memory. This can be seen in Listing~\ref{lst:goroutine}. Of course, unlike in
the example, the channel may also be buffered and would thus only block sends
when the buffer is full and receives when the buffer is empty. This is one of
the reasons that we chose Google Go: it allows us to use message passing
without the overhead of actually sending the message.

The \texttt{goroutines} fit the actor model of type resolution nicely since
the threads are lightweight and communication is easy to arrange. We may even
take advantage of the fact that not messages but references are passed through
\texttt{channels}. This way, a specific context will update everywhere that it
is referenced and we must only notify other actors that something changed
instead of sending the context again. This reduces communication overhead while
still functioning as a message passing system.

\section{Analysis and Model}

% variables: number of functions, function calls, contexts, partial contexts,
% undecidability, number of physical cores available, number of types and
% type classes, etc

\begin{figure*}
	% spans two columns
\centering
\begin{ganttchart}[
    vgrid,
	time slot format/start date=2014-04-14,
	time slot format=isodate,
	bar height=.5,
	y unit chart=0.6cm,
    %today=9,
    %bar/.append style={fill=green},
	%bar tyler/.append style={fill=green},
	%bar ben/.append style={fill=blue},
	%bar chris/.append style={fill=red}
]{2014-04-14}{2014-05-02}
\gantttitlecalendar{month=name, day, week} \\
\ganttbar{Proposal due}{2014-04-14}{2014-04-14}\\
\ganttbar{Design objects and communications}{2014-04-15}{2014-04-18}\\
\ganttchris{Error types}{2014-04-14}{2014-04-15}\\
\ganttben{}{2014-04-14}{2014-04-15}\\
\gantttyler{A Tyler task}{2014-04-14}{2014-04-15}\\
\ganttbar{A group task}{2014-04-14}{2014-04-15}
\end{ganttchart}
\vspace{3mm} % fix weird caption placement
\caption{Timeline: tasks for Tyler (green), Ben (blue), Chris (red), and the
group (white)}
\label{fig:schedule}
\end{figure*}

\section{Team and Timeline}

Our group consists of three team members: Tyler, Ben, and Chris.
Figure~\ref{fig:schedule} depicts a Gantt chart that shows all team member's
tasks.

We have developed a list of goals ordered by priority:
\begin{description}
	\item[First order goals]
	\item[Second order goals]
	\item[Third order goals]
\end{description}

\section{Conclusion}

\appendix
\section{EBNF Grammar Definition}
    \label{app:Grammar}
    \begin{grammar}

    <lower-letter> ::= `...';

    <upper-letter> ::= `...';

    <type-name> ::= <lower-letter>, \{<upper-letter> |
    \\ <lower-letter>\};

    <error-name> ::= <lower-letter>, \{<upper-letter>
    \\ | <lower-letter>\};

    <typeclass-name> ::= <upper-letter>, \{<upper-letter>
    \\ | <lower-letter>\};

    <type-var> ::= <upper-letter>, \{<upper-letter>\};

    <var> ::= <lower-letter>, \{<lower-letter>\}

    <func-name> ::= <lower-letter>, \{<upper-letter>
    \\ | <lower-letter>\};

    <func-arg> ::= (<type-var> | <type-name>), ` ', <var>

    <func-args> ::= `(', \{<func-arg>, `, '\}, <func-arg>, `)';

    <func-constraint> ::= <type-var>, ` to ', <typeclass-name>,
    \\ \{` ', <typeclass-name>\};

    <func-constraints> ::= `constrain ', <func-constraint>,
    \\ \{<func-constraint>\};

    <func-errors> ::= ` throws ', <error-name>,
    \\ \{`, ', <error-name>\};

    <typeclass-inherit> ::= ` inherits ', <typeclass-name>,
    \\ \{`, ', <typeclass-name>\};

    <type-implement> ::= ` implements ', <typeclass-name>,
     \\\{`,', <typeclass-name>\};

    <type-decl> ::= `type ', <type-name>, [<type-implement>];

    <typeclass-decl> ::= `typeclass ',
    \\<typeclass-name>, [<typeclass-inherit>];

    <func-decl> ::= `func ', <func-name>, [<func-constraints>], <func-args>, [<func-errors>];

    \end{grammar}


% why appropriate project?

\balancecolumns
\end{document}
