% THIS IS SIGPROC-SP.TEX - VERSION 3.1
% WORKS WITH V3.2SP OF ACM_PROC_ARTICLE-SP.CLS
% APRIL 2009
%
% It is an example file showing how to use the 'acm_proc_article-sp.cls' V3.2SP
% LaTeX2e document class file for Conference Proceedings submissions.
% ----------------------------------------------------------------------------------------------------------------
% This .tex file (and associated .cls V3.2SP) *DOES NOT* produce:
%       1) The Permission Statement
%       2) The Conference (location) Info information
%       3) The Copyright Line with ACM data
%       4) Page numbering
% ---------------------------------------------------------------------------------------------------------------

\documentclass{acm_proc_article-sp}
\usepackage{listings,color,xcolor}
\usepackage{pgf,tikz,pgfgantt}

\usepackage{subcaption}
\usepackage{graphicx}
\usepackage{float,dblfloatfix,fixltx2e}
\usepackage[format=plain,font=small,labelfont=bf]{caption}
\usepackage[utf8]{inputenc}
\usepackage{syntax, etoolbox}
\usepackage[toc, page]{appendix}
\usepackage{glossaries}

\definecolor{dkgreen}{rgb}{0,0.6,0}
\AtBeginEnvironment{grammar}{\small}

\usepackage{MnSymbol}
\lstset{
	prebreak=\raisebox{0ex}[0ex][0ex]{\ensuremath{\rhookswarrow}},
	postbreak=\raisebox{0ex}[0ex][0ex]{\ensuremath{\rcurvearrowse\space}},
	breaklines=true,
	breakatwhitespace=true
}

\lstdefinestyle{paratype}{
	breaklines=true,
	numbers=left,
	basicstyle=\small\ttfamily,
	keywords={func,inherits,implements,throws,type,typeclass},
	keywordstyle=\bfseries\color{dkgreen},
	commentstyle=\itshape\color{purple},
	identifierstyle=\color{black},
	stringstyle=\color{blue},
	numberstyle=\scriptsize,
	frame=single,
	frameround=tttt,
	tabsize=4,
	showstringspaces=false,
	aboveskip=1.8em,
	belowskip=0em,
	captionpos=b,
	xleftmargin=1.8em,
	xrightmargin=0.5em
}

\newganttchartelement{chris}{
	chris/.style={
		color=black,
		fill=red,
		shape=ganttbar,
		inner sep=0pt,
		draw
	},
	chris height=0.5
}
\newganttchartelement{tyler}{
	tyler/.style={
		color=black,
		fill=green,
		shape=ganttbar,
		inner sep=0pt,
		draw
	},
	tyler height=.5
}
\newganttchartelement{ben}{
	ben/.style={
		color=black,
		fill=blue,
		shape=ganttbar,
		inner sep=0pt,
		draw
	},
	ben height=.5
}

\setlength{\grammarparsep}{8pt plus 1pt minus 1pt}
\setlength{\grammarindent}{12em}

\begin{document}

\title{Paratype --- A Parallel Type Completion System}


% You need the command \numberofauthors to handle the 'placement
% and alignment' of the authors beneath the title.
\numberofauthors{3}
\author{
\alignauthor
Tyler Cecil\\
       \affaddr{New Mexico Tech}\\
       \affaddr{801 Leroy Place}\\
       \affaddr{Socorro, NM 87801 USA}\\
       \email{tcecil@nmt.edu}
\alignauthor
Ben Turrubiates\\
       \affaddr{New Mexico Tech}\\
       \affaddr{801 Leroy Place}\\
       \affaddr{Socorro, NM 87801 USA}\\
       \email{bturrubi@nmt.edu}
\alignauthor
Christopher Koch\\
       \affaddr{New Mexico Tech}\\
       \affaddr{801 Leroy Place}\\
       \affaddr{Socorro, NM 87801 USA}\\
       \email{ckoch@cs.nmt.edu}
}
\date{\today}

\maketitle
\begin{abstract}
\end{abstract}

\category{F.3.3}{Studies of Program Constructs}{Type structure}
\category{D.3.3}{Programming Languages}{Language Constructs and Features}
\category{D.3.4}{Programming Languages}{Processors}

% some out of 16 general terms!
\terms{Design, Languages, Performance}

\keywords{type theory, language theory, type completion, type checking, type
inference, code analysis}

\section{Introduction}

% problem and why important
% compilers: e.g. just-in-time comp

\section{Problem Definition}

% grammar, input/output, type completion, lambda calculus (System F)

Formally, our problem will be to take an input file of a specified grammar and
generate an output of either failure due to indecidability or the same file
with explicit types instead of type variables. In the process of doing this, we
will also be performing typechecking. The goal is to find an explicit type for
each function call without type conflicts. Please see Figure~\ref{fig:grammar}
for our EBNF grammar.

We define a few terms to use throughout the proposal:
\begin{description}
	\item[Type] A set of values. Types may implement type classes.
	\item[Type class] A set of types. Typeclasses may inherit other type classes.
	\item[Context] The set of explicit types and metainformation associated
		with a function call: caller, parameter types, return type,
		and a list of functions who care about the context.
	\item[Partial context] A context where not all types are known explicitly.
	\item[Resolution] Resolving a context means giving it explicit types.
	\item[Parent (function)] Caller of a function.
	\item[Child (function)] A function that is called by its parent function.
\end{description}

\begin{lstlisting}[caption=Grammar displayed informally,style=paratype]
typeclass T inherits T1, T2, ...

type A implements T
    = Type | (Type, Type, ...)

func foo(Type var, Typevar var2, ...)
    Type throws Error1, Error2, Error3
    = bar(baz(var), var2) | Type
\end{lstlisting}

\section{Parallelization}

Paratype will act as an \emph{Actor model} of computation for our type
system: \emph{every function will be an actor}. We feel that not only will
such a model be efficient for type resolution, but also acts as a
natural solution to the problem. The type resolution process is
essentially a conversation between functions: a function asks others for
information about their type in order to reselve its own type. We take
advantage of this natural communication, and process the problem in
parallel.

Unfortunatly the communication is not linear (as shown by our
preivious examples). This makes our task quite a bit more challanging
(especially if we want to keep comunication overhead down)! Each node
needs to communicated to its parents and children, send partial
contexts, and update error types. Actors also need to know when their
process should finish, compile, or error out. This complexity,
however, is not all for not.

\subsection{Expected Speedup}

Where does speedup come from, other than the parallel computation of
contexts? Consider a chain of function calls, in which the last
function in the chain has a type constraint. In the serial case, types
would need to propigate all the way down to check for a type error. In
the parallel case, however, contexts move both up and down,
concurently; meeting half-way, we can check for type errors. This
is only one factor (that only matters in invalid code). However, the
chains themselves can now be evaluated in parallel. If we are even
more clever, we can use shared memory for our contexts, allowing
changes that occur at one end of a call graph to instantly propigate
to all other nodes, without unnecessary message overhead. When
considering the factors provide speedup for our application, it
becomes apparent that our speedup is a function of many atributes ---
graph width, number of functions, invalid versus valid code, ect\ldots
These need to be considered when building our model.

In some ways, speedup will be hard to measure --- we don't have a serial
implementation for our toy language. Due to time constraints, we
have omitted implicit typing from our grammar (not that our system
could not handle it), preventing us from simply resolving haskell
types, and compareing our results to \texttt{gch} and
\texttt{hugs}. This acts as a future goal for us. At present, however,
we will be able to varry the number of processing nodes being
utilized, via \texttt{GOMAXPROCS}.

\subsection{Expected Problems}

Moving contexts around is no trivial task. A huge amount of
bookkeeping will be required to prevent deadlock, hanging, unnecessary
contexts, and host of other possible problems. Marking down where a
context came from is not even triviall --- through composition of
function calls an inner function of that composition may receive
contexts through wrapping functions of that composition. While none of
these problems are insurmountable, they require our code to be
constructed carefully.

%TODO: USE AN ACTUALL LABEL
Our examples in Section 2 show a number of problems that must be
resolved in our method. Perhaps the most daunting is knowing when
execution should complete. More subtilly, however, are problems that
come from having no ``main'' function. In a traditional compiler
setting, we have a function to begin propegation from. We, however,
evaluation all contexts in parallel. With this lack of starting point,
some communications become ambiguous --- do we communicate down or up
the call tree, do we wait to be signaled, ect\ldots These are all
problems that will need to be resolved by Paratype.

\section{Methods}

% Google Go and why

Due to the actor model, the problem lends itself nicely to a distributed memory
approach; however, it is usually commodity hardware that is used for
compilation. Therefore, we propose to use Google Go due to its concept of
\texttt{goroutines}. A \texttt{goroutine} acts like a process or a thread (like
a processing unit). It is possible to pass references through shared memory,
called \texttt{channels}, with \texttt{goroutines}: like message passing in
shared memory.

We may even take advantage of the fact that not messages but references are
passed through \texttt{channels}. This way, a specific context will update
everywhere that it is referenced and we must only notify other actors that
something changed instead of sending the context again.


\section{Analysis and Model}

% variables: number of functions, function calls, contexts, partial contexts,
% indecidability, number of physical cores available, number of types and
% typeclasses, etc

\begin{figure*}
	% spans two columns
\centering
\begin{ganttchart}[
    vgrid,
	time slot format/start date=2014-04-14,
	time slot format=isodate,
	bar height=.5,
	y unit chart=0.6cm,
    %today=9,
    %bar/.append style={fill=green},
	%bar tyler/.append style={fill=green},
	%bar ben/.append style={fill=blue},
	%bar chris/.append style={fill=red}
]{2014-04-14}{2014-05-02}
\gantttitlecalendar{month=name, day, week} \\
\ganttbar{Proposal Due}{2014-04-14}{2014-04-14}\\
\ganttchris{A Chris task}{2014-04-14}{2014-04-15}\\
\ganttben{A Ben task}{2014-04-14}{2014-04-15}\\
\gantttyler{A Tyler task}{2014-04-14}{2014-04-15}\\
\ganttbar{A group task}{2014-04-14}{2014-04-15}
\end{ganttchart}
\vspace{3mm} % fix weird caption placement
\caption{Timeline: tasks for Tyler (green), Ben (blue), Chris (red), and the
group (white)}
\label{fig:schedule}
\end{figure*}

\section{Team and Timeline}

Our group consists of three team members: Tyler, Ben, and Chris.
Figure~\ref{fig:schedule} depicts a Gantt chart that shows all team member's
tasks.

We have developed a list of goals ordered by priority:
\begin{description}
	\item[First order goals]
	\item[Second order goals]
	\item[Third order goals]
\end{description}

\section{Conclusion}

\begin{appendices}
    \section{Formal Grammar Definition}
%        \begin{figure*}
            \begin{grammar}

            <lower-letter> ::= `...';

            <upper-letter> ::= `...';

            <type-name> ::= <lower-letter>, \{<upper-letter> |
            \\ <lower-letter>\};

            <error-name> ::= <lower-letter>, \{<upper-letter> 
            \\ | <lower-letter>\};

            <typeclass-name> ::= <upper-letter>, \{<upper-letter> 
            \\ | <lower-letter>\};

            <type-var> ::= <upper-letter>, \{<upper-letter>\};

            <var> ::= <lower-letter>, \{<lower-letter>\}

            <func-name> ::= <lower-letter>, \{<upper-letter> 
            \\ | <lower-letter>\};

            <func-arg> ::= (<type-var> | <type-name>), ` ', <var>

            <func-args> ::= `(', \{<func-arg>, `, '\}, <func-arg>, `)';

            <func-constraint> ::= <type-var>, ` to ', <typeclass-name>,
            \\ \{` ', <typeclass-name>\};

            <func-constraints> ::= `constrain ', <func-constraint>, 
            \\ \{<func-constraint>\};

            <func-errors> ::= ` throws ', <error-name>, 
            \\ \{`, ', <error-name>\};

            <typeclass-inherit> ::= ` inherits ', <typeclass-name>, 
            \\ \{`, ', <typeclass-name>\};

            <type-implement> ::= ` implements ', <typeclass-name>, 
             \\\{`,', <typeclass-name>\};

            <type-decl> ::= `type ', <type-name>, [<type-implement>];

            <typeclass-decl> ::= `typeclass ', 
            \\<typeclass-name>, [<typeclass-inherit>];

            <func-decl> ::= `func ', <func-name>, [<func-constraints>], <func-args>, [<func-errors>];

            \end{grammar}
%            \caption{Extended BNF Grammar}
%            \label{fig:grammar}
%        \end{figure*}
\end{appendices}

% why appropriate project?

\balancecolumns
\end{document}
