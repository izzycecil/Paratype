% THIS IS SIGPROC-SP.TEX - VERSION 3.1
% WORKS WITH V3.2SP OF ACM_PROC_ARTICLE-SP.CLS
% APRIL 2009
%
% It is an example file showing how to use the 'acm_proc_article-sp.cls' V3.2SP
% LaTeX2e document class file for Conference Proceedings submissions.
% ----------------------------------------------------------------------------------------------------------------
% This .tex file (and associated .cls V3.2SP) *DOES NOT* produce:
%       1) The Permission Statement
%       2) The Conference (location) Info information
%       3) The Copyright Line with ACM data
%       4) Page numbering
% ---------------------------------------------------------------------------------------------------------------

\documentclass{acm_proc_article-sp}
\usepackage{listings,color,xcolor}
\usepackage{pgf,tikz,pgfgantt}

\usepackage{subcaption}
\usepackage{graphicx}
\usepackage{float,dblfloatfix,fixltx2e}
\usepackage[format=plain,font=small,labelfont=bf]{caption}
\usepackage[utf8]{inputenc}
\usepackage{syntax, etoolbox}
\usepackage[toc, page]{appendix}
\usepackage{glossaries}

\definecolor{dkgreen}{rgb}{0,0.6,0}
\AtBeginEnvironment{grammar}{\small}

\usepackage{MnSymbol}
\lstset{
	prebreak=\raisebox{0ex}[0ex][0ex]{\ensuremath{\rhookswarrow}},
	postbreak=\raisebox{0ex}[0ex][0ex]{\ensuremath{\rcurvearrowse\space}},
	breaklines=true,
	breakatwhitespace=true
}

\lstdefinestyle{paratype}{
	breaklines=true,
	numbers=left,
	basicstyle=\small\ttfamily,
	keywords={func,inherits,implements,throws,type,typeclass},
	keywordstyle=\bfseries\color{dkgreen},
	commentstyle=\itshape\color{purple},
	identifierstyle=\color{black},
	stringstyle=\color{blue},
	numberstyle=\scriptsize,
	frame=single,
	frameround=tttt,
	tabsize=4,
	showstringspaces=false,
	aboveskip=1.8em,
	belowskip=0em,
	captionpos=b,
	xleftmargin=1.8em,
	xrightmargin=0.5em
}

\newganttchartelement{chris}{
	chris/.style={
		color=black,
		fill=red,
		shape=ganttbar,
		inner sep=0pt,
		draw
	},
	chris height=0.5
}
\newganttchartelement{tyler}{
	tyler/.style={
		color=black,
		fill=green,
		shape=ganttbar,
		inner sep=0pt,
		draw
	},
	tyler height=.5
}
\newganttchartelement{ben}{
	ben/.style={
		color=black,
		fill=blue,
		shape=ganttbar,
		inner sep=0pt,
		draw
	},
	ben height=.5
}

\setlength{\grammarparsep}{8pt plus 1pt minus 1pt}
\setlength{\grammarindent}{12em}

\begin{document}

\title{Paratype --- A Parallel Type Completion System}


% You need the command \numberofauthors to handle the 'placement
% and alignment' of the authors beneath the title.
\numberofauthors{3}
\author{
\alignauthor
Tyler Cecil\\
       \affaddr{New Mexico Tech}\\
       \affaddr{801 Leroy Place}\\
       \affaddr{Socorro, NM 87801 USA}\\
       \email{tcecil@nmt.edu}
\alignauthor
Ben Turrubiates\\
       \affaddr{New Mexico Tech}\\
       \affaddr{801 Leroy Place}\\
       \affaddr{Socorro, NM 87801 USA}\\
       \email{bturrubi@nmt.edu}
\alignauthor
Christopher Koch\\
       \affaddr{New Mexico Tech}\\
       \affaddr{801 Leroy Place}\\
       \affaddr{Socorro, NM 87801 USA}\\
       \email{ckoch@cs.nmt.edu}
}
\date{\today}

\maketitle
\begin{abstract}
\end{abstract}

\category{F.3.3}{Studies of Program Constructs}{Type structure}
\category{D.3.3}{Programming Languages}{Language Constructs and Features}
\category{D.3.4}{Programming Languages}{Processors}

% some out of 16 general terms!
\terms{Design, Languages, Performance}

\keywords{type theory, language theory, type completion, type checking, type
inference, code analysis}

\section{Introduction}

% problem and why important
% compilers: e.g. just-in-time comp

\section{Problem Definition}

% grammar, input/output, type completion, lambda calculus (System F)

Formally, our problem will be to take an input file of a specified grammar and
generate an output of either failure due to indecidability or the same file
with explicit types instead of type variables. In the process of doing this, we
will also be performing typechecking. The goal is to find an explicit type for
each function call without type conflicts. Please see Figure~\ref{fig:grammar}
for our EBNF grammar.

We define a few terms to use throughout the proposal:
\begin{description}
	\item[Type] A set of values. Types may implement type classes.
	\item[Type class] A set of types. Typeclasses may inherit other type classes.
	\item[Context] The set of explicit types and metainformation associated
		with a function call: caller, parameter types, return type,
		and a list of functions who care about the context.
	\item[Partial context] A context where not all types are known explicitly.
	\item[Resolution] Resolving a context means giving it explicit types.
	\item[Parent (function)] Caller of a function.
	\item[Child (function)] A function that is called by its parent function.
\end{description}

\begin{lstlisting}[caption=Grammar displayed informally,style=paratype]
typeclass T inherits T1, T2, ...

type A implements T
    = Type | (Type, Type, ...)

func foo(Type var, Typevar var2, ...)
    Type throws Error1, Error2, Error3
    = bar(baz(var), var2) | Type
\end{lstlisting}

\section{Parallelization}

For parallelization, we propose to use an actor model: each processing unit
acts as one function. For each function call, a node must resolve its contexts
(its explicit types) through communicating with other nodes: its parents and
children. Also, through composition of function calls an inner function of that
composition may receive contexts through wrapping functions of that
composition.

An actor with explicit context may resolve other actors' partial contexts,
while sometimes two actors with partial contexts can resolve each others'
contexts.

% actor model, functions as nodes, DAG

\section{Methods}

% Google Go and why

Due to the actor model, the problem lends itself nicely to a distributed memory
approach; however, it is usually commodity hardware that is used for
compilation. Therefore, we propose to use Google Go due to its concept of
\texttt{goroutines}. A \texttt{goroutine} acts like a process or a thread (like
a processing unit). It is possible to pass references through shared memory,
called \texttt{channels}, with \texttt{goroutines}: like message passing in
shared memory.

We may even take advantage of the fact that not messages but references are
passed through \texttt{channels}. This way, a specific context will update
everywhere that it is referenced and we must only notify other actors that
something changed instead of sending the context again.


\section{Analysis and Model}

% variables: number of functions, function calls, contexts, partial contexts,
% indecidability, number of physical cores available, number of types and
% typeclasses, etc

\begin{figure*}
	% spans two columns
\centering
\begin{ganttchart}[
    vgrid,
	time slot format/start date=2014-04-14,
	time slot format=isodate,
	bar height=.5,
	y unit chart=0.6cm,
    %today=9,
    %bar/.append style={fill=green},
	%bar tyler/.append style={fill=green},
	%bar ben/.append style={fill=blue},
	%bar chris/.append style={fill=red}
]{2014-04-14}{2014-05-02}
\gantttitlecalendar{month=name, day, week} \\
\ganttbar{Proposal due}{2014-04-14}{2014-04-14}\\
\ganttbar{Design objects and communications}{2014-04-15}{2014-04-18}\\
\ganttchris{Error types}{2014-04-14}{2014-04-15}\\
\ganttben{}{2014-04-14}{2014-04-15}\\
\gantttyler{A Tyler task}{2014-04-14}{2014-04-15}\\
\ganttbar{A group task}{2014-04-14}{2014-04-15}
\end{ganttchart}
\vspace{3mm} % fix weird caption placement
\caption{Timeline: tasks for Tyler (green), Ben (blue), Chris (red), and the
group (white)}
\label{fig:schedule}
\end{figure*}

\section{Team and Timeline}

Our group consists of three team members: Tyler, Ben, and Chris.
Figure~\ref{fig:schedule} depicts a Gantt chart that shows all team member's
tasks.

We have developed a list of goals ordered by priority:
\begin{description}
	\item[First order goals]
	\item[Second order goals]
	\item[Third order goals]
\end{description}

\section{Conclusion}

\begin{appendices}
    \section{Formal Grammar Definition}
%        \begin{figure*}
            \begin{grammar}

            <lower-letter> ::= `...';

            <upper-letter> ::= `...';

            <type-name> ::= <lower-letter>, \{<upper-letter> |
            \\ <lower-letter>\};

            <error-name> ::= <lower-letter>, \{<upper-letter> 
            \\ | <lower-letter>\};

            <typeclass-name> ::= <upper-letter>, \{<upper-letter> 
            \\ | <lower-letter>\};

            <type-var> ::= <upper-letter>, \{<upper-letter>\};

            <var> ::= <lower-letter>, \{<lower-letter>\}

            <func-name> ::= <lower-letter>, \{<upper-letter> 
            \\ | <lower-letter>\};

            <func-arg> ::= (<type-var> | <type-name>), ` ', <var>

            <func-args> ::= `(', \{<func-arg>, `, '\}, <func-arg>, `)';

            <func-constraint> ::= <type-var>, ` to ', <typeclass-name>,
            \\ \{` ', <typeclass-name>\};

            <func-constraints> ::= `constrain ', <func-constraint>, 
            \\ \{<func-constraint>\};

            <func-errors> ::= ` throws ', <error-name>, 
            \\ \{`, ', <error-name>\};

            <typeclass-inherit> ::= ` inherits ', <typeclass-name>, 
            \\ \{`, ', <typeclass-name>\};

            <type-implement> ::= ` implements ', <typeclass-name>, 
             \\\{`,', <typeclass-name>\};

            <type-decl> ::= `type ', <type-name>, [<type-implement>];

            <typeclass-decl> ::= `typeclass ', 
            \\<typeclass-name>, [<typeclass-inherit>];

            <func-decl> ::= `func ', <func-name>, [<func-constraints>], <func-args>, [<func-errors>];

            \end{grammar}
%            \caption{Extended BNF Grammar}
%            \label{fig:grammar}
%        \end{figure*}
\end{appendices}

% why appropriate project?

\balancecolumns
\end{document}
